# Ключевые концепции


Dishka - это DI-фреймворк, разработанный для создания сложных объектов, следуя принципу внедрения зависимостей. Давайте начнем с некоторых терминов.

# Зависимость(Dependency)

**Зависимость** - это то, что необходимо некоторым частям вашего кода для работы. Если вашему *шлюзу базы данных* нужно *соединение с базой данных* для выполнения SQL-запросов, тогда соединение является зависимостью для шлюза. Если ваш класс бизнес-логики требует шлюз базы данных или некий *api клиент*, тогда *api клиент* и *шлюз базы данных* являются зависимостями для бизнес-логики. Здесь `Client` является зависимостью, в то время как `Service` является зависимым.

```python
class Service:
        def __init__(self, client: Client):
            self.client = client
```

Таким образом, зависимость - это просто объект, требуемый другим объектом. Зависимости могут зависеть от других объектов, которые являются их зависимостями.

Чтобы следовать правилу внедрения зависимостей, зависимые объекты должны получать свои зависимости, а не запрашивать их самостоятельно. Одни и те же классы могут быть инстанцированы с разными значениями их зависимостей. По крайней мере в тестах.


# Область видимости (Scope)

**Область видимости** - это время жизни зависимости. Некоторые зависимости живут в течение всего времени работы приложения, в то время как другие создаются и уничтожаются с каждым запросом. В более редких случаях вам нужны объекты с еще более коротким временем жизни. Вы устанавливаете область видимости для каждой зависимости при настройке её создания.


Стандартные области видимости (с некоторыми пропущенными):

>  `APP` -> `REQUEST` -> `ACTION` -> `STEP`
   

Вы решаете, когда входить и выходить из каждой области видимости, но это делается последовательно. Если вы входите в область `APP`, то следующим шагом глубже будет вход в область `REQUEST`.

> [!NOTE]
> Область `APP` может использоваться для ленивой инициализации синглтонов, в то время > как область `REQUEST` хороша для обработки событий, таких как HTTP-запросы или 
> обновления мессенджера. Маловероятно, что вам понадобятся другие области видимости


В Dishka зависимости ленивые — они создаются при первом запросе. Если одна и та же зависимость запрашивается несколько раз в пределах одной области видимости, то возвращается тот же экземпляр (вы можете отключить это для каждой зависимости отдельно). Созданная зависимость сохраняется до тех пор, пока вы не выйдете из области видимости. И в этот момент она не просто отбрасывается, а выполняются соответствующие шаги финализации. Вы можете входить в одну и ту же область видимости несколько раз одновременно, чтобы иметь несколько экземпляров объектов, с которыми можно работать одновременно.

Каждый объект может зависеть от других объектов из той же или предыдущих областей видимости. Так, если у вас есть `Config` с областью видимости *APP* и `Connection` с областью видимости *REQUEST*, вы не можете иметь объект с областью видимости *APP*, который требует соединение, но вы можете иметь объект с областью видимости *REQUEST*, который требует `Connection` или `Config` (или даже оба).

Для веб-приложения входите в область `APP` при запуске и в область `REQUEST` для каждого HTTP-запроса.

Вы можете создать пользовательскую область видимости, определив свой собственный класс `Scope`, если стандартный поток областей видимости не соответствует вашим потребностям.

[Подробнее о пользовательских и пропущенных областях видимости]()

# Контейнер(Container)

**Контейнер** - это объект, который вы используете для получения ваших зависимостей.

Вы просто вызываете `.get(SomeType)`, и он находит способ предоставить вам экземпляр этого типа. Сам контейнер не создает объекты, но управляет их жизненным циклом и кэшами. Он делегирует создание объектов провайдерам, которые передаются при создании.

Каждый контейнер привязан к определенной области видимости. Чтобы войти во вложенную область, вы вызываете его и используете как контекстный менеджер. Согласно порядку областей видимости, контейнер может использоваться для получения зависимостей из своей собственной и предыдущих областей.

```python
app_container = make_container(provider1, provider2)  # вход в область APP

config = app_container.get(Config)  # объект области APP

with container() as request_container:  # вход в область REQUEST
    connection = request_container.get(Connection)  # объект области REQUEST
    config = request_container.get(Config)  # объект области APP
```

Асинхронный контейнер работает таким же образом, но вы должны использовать асинхронный контекстный менеджер и await результат `.get`.

Некоторые контейнеры безопасны для параллельного использования, другие нет: это настраивается при вызове контекстного менеджера. Для веб-приложений хорошо иметь контейнер области APP, безопасный для потоков/задач, но контейнеры области REQUEST этого не требуют, и это поведение по умолчанию.


[Подробнее об API контейнера]()

# Провайдер

**Провайдер** - это объект, члены которого используются для конструирования зависимостей. Это обычный объект, но некоторые атрибуты должны быть помечены специальными декораторами, чтобы они использовались контейнером. Чтобы создать свой собственный провайдер, вы наследуетесь от класса Provider и создаете его экземпляр при создании контейнера:

```python
class MyProvider(Provider):
    pass

container = make_container(MyProvider())
```


Есть 4 специальные функции:
* `@provide` используется для объявления фабрики, предоставляющей зависимость. Может использоваться с каким-либо классом или как декоратор метода. [Подробнее]()
*  `alias` используется для возможности получения одного и того же объекта по разным подсказкам типов. [Подробнее]()
* `from_context` используется для пометки зависимости как данных контекста, которые будут установлены вручную при входе в область видимости. [Подробнее]()
* `@decorate` используется для модификации или обертывания объекта, который уже настроен в другом `Provider`. [Подробнее]()


# Компонент

**Компонент** - это изолированная группа провайдеров внутри одного контейнера, идентифицируемая уникальной строкой. Когда запрашивается зависимость, она ищется только в том же компоненте, что и её прямой зависимый объект, если явно не указано иное.

Такая структура позволяет строить различные части приложения отдельно, не беспокоясь об использовании одних и тех же типов.

```python
class MainProvider(Provider):

    @provide(scope=Scope.APP)
    def foo(self, a: Annotated[int, FromComponent("X")]) -> float:
        return a/10

    @provide(scope=Scope.APP)
    def bar(self, a: int) -> complex:
        return a + 0j


class AdditionalProvider(Provider):
    component = "X"

    @provide(scope=Scope.APP)
    def foo(self) -> int:
        return 1


container = make_container(MainProvider(), AdditionalProvider())
container.get(float)  # возвращает 0.1
container.get(complex)  # вызывает NoFactoryError
```

[Подробнее об управлении компонентами]()
