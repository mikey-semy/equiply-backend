Dependency injection
*************************

# Что такое Внедрение зависимостей (Dependency)?
==================================

Внедрение зависимостей - это простая идея, которая говорит о том, что если какому-то объекту требуется другой объект для работы, он должен получить его извне, вместо того чтобы создавать или запрашивать этот объект самостоятельно.

Представьте, что у вас есть бизнес-логика, которая использует некий клиент удаленного API

```python
class Service:
    def action(self):
        client = Client(token)
        client.get_data()

service = Service()
service.action()
```

Здесь `client` является **зависимостью**. Представьте, что у вас много методов, работающих с одним и тем же клиентом, и каждый метод знает, как создать клиента. Тогда: подумайте над этими вопросами?

* Как они получают `token`? Должен ли каждый метод читать его самостоятельно?
* Что если конструктору `Client` потребуется больше одного токена? Должны ли мы копировать-вставлять новые параметры в каждый метод?
* Как мы заменим `client` моком при тестировании этих методов?
* Как мы узнаем, какая часть кода может использовать `client`?
* Как мы можем повторно использовать один и тот же клиент, если он становится с состоянием? Как мы можем использовать несколько клиентов в разных случаях?

Надеюсь, к этому моменту вы начали подозревать, что здесь есть проблема. Чтобы решить её, давайте создадим нашу **зависимость** где-то вне этого метода и **внедрим** её. Есть три способа сделать это:

1. **Внедрение через параметр**. Мы можем передать клиента в метод как параметр.

```python
class Service:
    def action(self, client: Client):
        client.get_data()

service = Service()
client = Client(token="1234567890")
service.action(client)
```

Это хорошо работает, если у вас нет множества методов и они не могут вызывать друг друга. Также мы меняем сигнатуру методов, что может привести к большим изменениям в коде и может быть невозможным, если есть ожидания относительно интерфейса объекта.

2. **Внедрение через конструктор**. Мы можем передать клиента при создании экземпляра сервиса. Все его методы будут иметь к нему доступ. Это основной способ реализации DI

```python
class Service:
    def __init__(self, client: Client):
        self.client = client

    def action(self):
        self.client.get_data()

token = os.getenv("TOKEN")
client = Client(token)
service = Service(client)
service.action()
```

3. **Внедрение через атрибут**. Мы можем хранить атрибут напрямую (или используя дополнительные методы) на созданном объекте. В основном используется в комбинации с внедрением через конструктор для изменения существующих объектов или для разрыва циклических ссылок между объектами. Например:

```python
class Service:
    client: Client

    def action(self):
        self.client.get_data()

service = Service(client)
service.client = Client(token)
service.action()
```

Дополнительно нужно назвать анти-паттерны, которых следует избегать, так как они не могут решить все проблемы, которые устраняются с помощью DI, хотя могут решить часть из них:

* *Глобальная переменная*. Хотя она позволяет нам повторно использовать зависимость и настраивать её вне нашей бизнес-логики, мы ограничены одним экземпляром навсегда. Также мы не контролируем, когда она создается и финализируется: какой-то код может попытаться использовать её до того, как она правильно настроена

* *Синглтон*. В основном это вариант глобальной переменной. Он может добавить ленивость, но другие характеристики те же.

* *Monkey patch*. Или `mock.patch()` как пример. Позволяет заменить поведение в тестах, но также полагается на детали того, как класс импортируется и используется, вместо его интерфейса. Это делает тесты более хрупкими и требует больше работы для их поддержки

Когда внедрять зависимости?
===================================

Для простых случаев очевидно, что у вас есть некоторые классы с их требованиями, и когда вы запускаете приложение, вы создаете их все и соединяете вместе. Но реальные приложения - более сложные вещи. Они оперируют десятками или даже сотнями объектов в сложной иерархии, они выполняют параллельную обработку.

Хорошая идея - отделить код, который использует зависимости, от кода, который их создает. Обычно мы хотим уменьшить знания о наших зависимостях в коде, который их использует. Но это не всегда возможно, так как разные объекты имеют разный жизненный цикл.

Например, конфигурация обычно загружается при запуске приложения, но транзакции базы данных (и соответствующие соединения с базой данных) должны открываться отдельно для каждого обрабатываемого HTTP-запроса. Поэтому неизбежно создание и завершение зависимостей где-то внутри обработки запроса. Другие зависимости будут иметь свои собственные **области видимости**, но часто их только две: время жизни приложения и каждый запрос.

Для веб-приложения это может выглядеть так:

```python
@app.get("/")
def index(request):
    client = Client(os.getenv("TOKEN"))
    service = Service(client)
    service.action()

@app.get("/foo")
def get_foo(request):
    client = Client(os.getenv("TOKEN"))
    service = Service(client)
    service.action()
```

Трюк в том, как управлять этими зависимостями, когда у вас много обработчиков запросов, не теряя возможности их тестировать.

* Один подход - создавать все эти зависимости в промежуточном ПО (это специальный объект, который вызывается вашим фреймворком при каждом событии). В псевдокоде это будет что-то вроде этого:

```python
def service_creator(request):
    client = Client(os.getenv("TOKEN"))
    service = Service(client)
    request.state.service = Service(client)

app.setup_middleware(service_creator)

@app.get("/")
def index(request):
    service = request.state.service
    service.action()
```

Это хорошо работает. У вас чистые обработчики запросов, и вы можете менять промежуточное ПО в тестах. Но это может стать проблемой, если у вас много объектов, создание которых не дешево.

* Второй подход - создать некую фабрику (назовем её **контейнером**) и вызывать её внутри обработчика запросов. Вы все еще можете использовать промежуточное ПО для передачи её в обработчик (проверьте также другие возможности вашего фреймворка)

```python
class Container:
    def get_client(self) -> Client:
        return Client(os.getenv("TOKEN"))

    def get_service(self) -> Service:
        return Service(self.get_client())

container = Container()
def container_middleware(request):
    request.state.container = container

app.setup_middleware(container_middleware)

@app.get("/")
def index(request):
    service = request.state.container.get_service()
    service.action()
```

По сравнению с промежуточным ПО это позволяет создавать только нужные объекты. Но остерегайтесь доступа к контейнеру из обработчиков через глобальную переменную - это сделает тесты более сложными в поддержке.

В обоих подходах вы можете контролировать, создается ли экземпляр при каждом запросе или один раз для приложения. Также вы можете иметь разное промежуточное ПО или контейнеры для продакшена и тестовых целей.


# Что такое IoC-контейнер?
=============================

IoC-контейнер - это специальный объект (или фреймворк, предоставляющий такой объект), который предоставляет требуемые объекты, следуя правилам внедрения зависимостей и управляет их жизненным циклом. DI-фреймворк - другое название для таких фреймворков.

Распространенная ошибка - считать IoC-контейнер единственным способом внедрения зависимостей. Это не имеет ничего общего с реальностью. Внедрение зависимостей может быть выполнено просто путем передачи одного объекта другому, но в сложном приложении это не так просто сделать. Как было показано выше, вы можете захотеть создать отдельный объект для инкапсуляции всей логики, связанной с DI. `Container` в предыдущем примере является примером написанного вручную примитивного IoC-контейнера.

Чем больше ваше приложение, тем более сложные фабрики вам нужны, тем более необходима автоматизация создания контейнера. Вам не нужно использовать IoC-контейнер для тестирования одной маленькой части приложения, но он может быть необходим для запуска его в целом. К счастью, для этого есть фреймворки. Но опять же, остерегайтесь распространения деталей, связанных с контейнером, по всему коду приложения, за исключением границ областей видимости.

Итак, говоря об IoC-контейнере, мы можем записать эти идеи:

* IoC-контейнер не является необходимым для внедрения зависимостей
* Это полезный помощник для больших приложений
* Он должен быть безопасным для использования в параллельном приложении
* Он должен следовать правилам, которые вы предоставляете для ваших зависимостей (единственный или множественные экземпляры, множественные области жизненного цикла и т.д.)

Подробнее о возможных требованиях вы можете прочитать [Technical requirements]https://dishka.readthedocs.io/en/stable/requirements/technical.html#technical-requirements).

Итак, пришло время для **dishka** - реализации IoC-контейнера со всем необходимым.